package com.khalekuzzamanjustcse.common_ui.graph_editor

import android.util.Log
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.khalekuzzamanjustcse.common_ui.command_pattern.AddEdgeCommand
import com.khalekuzzamanjustcse.common_ui.command_pattern.AddNodeCommand
import com.khalekuzzamanjustcse.common_ui.command_pattern.UndoManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update

class GraphEditorCanvas(
    private val minSize: Dp,
    private val minSizePx: Float,
    private val isDirected: Boolean = false,
  private val onInputDone:(GraphEditorResult)->Unit={},
) {
    //Observable callback for when edges need to updated
    private val _visualEdges = MutableStateFlow(listOf<DrawingEdge>())
    val visualEdges = _visualEdges.asStateFlow()
    private val reDrawEdges: (Set<Edge>) -> Unit = { basicEdges ->
        _visualEdges.update { getDrawingEdges(basicEdges) }
    }

    //nodes maneging
    private val _visualNodes = MutableStateFlow(setOf<GraphEditorVisualNode>())
    val visualNodes = _visualNodes.asStateFlow()
    private val onGraphNodesUpdated: (Set<GraphBasicNode>) -> Unit = { basicNodes ->
        _visualNodes.update {
            basicNodes.map { basicNode ->
                GraphEditorVisualNode(
                    basicNode = basicNode, size = basicNode.size, sizePx = basicNode.sizePx,
                    onClick = ::onNodeClick, onDragEnd = ::onNodeDragEnd
                )
            }.toSet()
        }
    }

    private var holder = GraphEditorGraphHolder(
        onEdgeUpdated = reDrawEdges,
        onNodesUpdated = onGraphNodesUpdated
    )

    /*
    Undo and redo operations

     */

    private val undoManager = UndoManager()
    val disableUndo: Boolean
        get() = undoManager.undoAvailable
    val disableRedo: Boolean
        get() = undoManager.redoAvailable

    fun undo() = undoManager.undo()
    fun redo() = undoManager.redo()


    private var autoGeneratedId = 0
    private val lastTwoClickedNode = arrayOfNulls<GraphEditorVisualNode?>(2)
    private var clickCount = 0


    private val _takeInput = MutableStateFlow(false)
    val takeInput = _takeInput.asStateFlow()
    private var lastClickedPosition = Offset.Zero

    fun onCanvasTap(offset: Offset) {
        lastClickedPosition = offset
    }

    fun onNodeInputRequest() {
        _takeInput.update { true }
    }

    private fun onNodeDragEnd(dragged: GraphEditorVisualNode) {
        holder.updateExistingNode(dragged)
    }

    fun onInputComplete(label: String, size: Dp = 0.dp, sizePx: Float = 0f) {
        _takeInput.update { false }
        val node = object : GraphBasicNode {
            override val id = autoGeneratedId++
            override val label = label
            override val position = lastClickedPosition
            override val sizePx = if (sizePx < minSizePx) minSizePx else sizePx
            override val size = if (size < minSize) minSize else size
        }
        val addNodeCommand = AddNodeCommand(node, holder)
        undoManager.execute(addNodeCommand)
    }


    fun addEdge() {
        val u = lastTwoClickedNode[0]
        val v = lastTwoClickedNode[1]
        if (u != null && v != null) {
            undoManager.execute(AddEdgeCommand(u, v, holder))
        }
    }

    private fun onNodeClick(node: GraphEditorVisualNode) {
        lastTwoClickedNode[clickCount % 2] = node
        clickCount++
    }

    fun makeAllNodeSameSize() {
        holder.makeHomogenous()
    }

    private fun getDrawingEdges(edgesRef: Set<Edge>): List<DrawingEdge> {
        val drawEdges = mutableListOf<DrawingEdge>()
        edgesRef.forEach { (uId, vId) ->
            val u = visualNodes.value.find { it.id == uId }
            val v = visualNodes.value.find { it.id == vId }
            if (u != null && v != null) {
                drawEdges.add(
                    DrawingEdge(
                        start = u.position + Offset(u.sizePx / 2, u.sizePx / 2),
                        end = v.position + Offset(v.sizePx / 2, v.sizePx / 2),
                        isDirected = isDirected
                    )
                )
            }
        }
        return drawEdges
    }

    fun onInputComplete() {
        val result=GraphEditorResult(
            nodes=holder.nodes.toList(),
            edges=holder.edges.toList(),
            isDirected=isDirected
        )
        onInputDone(result)
        Log.i("AdjacencyList:Graph: ", "${result.adjacencyList}")
        Log.i("AdjacencyList:Graph: ", "${result.isTree}")
        Log.i("AdjacencyList:BT: ", "${result.isBinaryTree}")
    }


}