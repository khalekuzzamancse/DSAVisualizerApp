package com.khalekuzzamanjustcse.graph_visualization.ui_layer.graph_editor

import android.util.Log
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.unit.Dp
import com.khalekuzzamanjustcse.graph_visualization.command_pattern.AddEdgeCommand
import com.khalekuzzamanjustcse.graph_visualization.command_pattern.AddNodeCommand
import com.khalekuzzamanjustcse.common_ui.command_pattern.UndoManager
import com.khalekuzzamanjustcse.graph_visualization.data_layer.Graph
import com.khalekuzzamanjustcse.graph_visualization.data_layer.GraphNode
import com.khalekuzzamanjustcse.graph_visualization.ui_layer.graph_draw.EdgeComposableState
import com.khalekuzzamanjustcse.graph_visualization.ui_layer.graph_draw.NodeComposableState
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

data class GraphEditorResult(
    val nodes: List<NodeComposableState> = emptyList(),
    val edges: List<EdgeComposableState> = emptyList(),
    val adjacencyList: Map<Int, List<Int>> = emptyMap()
) {
    val maxYOffsetNode: Float
        get() {
            return nodes.maxBy { it.offset.y }.offset.y
        }
}

class GraphEditorState(
    private val size: Dp,
    private val sizePx: Float,
    private val onInputComplete: (GraphEditorResult) -> Unit = {},
) {

    private var autoGeneratedId = 0
    private val graph = Graph<String>()
    private val _nodes = MutableStateFlow(emptyList<NodeComposableState>())
    private val _edges = MutableStateFlow(emptyList<EdgeComposableState>())
    val nodes = _nodes.asStateFlow()
    val edges = _edges.asStateFlow()
    private val adjacencyList
        get() = graph.adjacencyListOfIds

    private val undoManager = UndoManager()
    val disableUndo: Boolean
        get() = undoManager.undoAvailable
    val disableRedo: Boolean
        get() = undoManager.redoAvailable

    fun undo() = undoManager.undo()
    fun redo() = undoManager.redo()


    fun addNode(data: String) {
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            val node = GraphNode(
                data = data,
                offset = lastTappedLocation,
                id = autoGeneratedId++
            )
           // graph.addNode(node)
            val addNodeCommand = AddNodeCommand(node, graph)
            undoManager.execute(addNodeCommand)
        }
    }

    //
    private val recentlyClickedNodes = Array(2) { 0 }
    private var clickCount = 0
    private var lastTappedLocation = Offset.Zero
    private var lastTappedNodeId = -1
    private val canvasCurrentMaxHeightPx= MutableStateFlow(sizePx+sizePx)



    //event handlers
    fun onDragEnd(nodeIndex: Int, offset: Offset) {
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            graph.onNodeDrag(nodeIndex, offset)
        }
    }


    fun onNodeClick(nodeId: Int) {
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            recentlyClickedNodes[clickCount % 2] = nodeId
            clickCount++
            lastTappedNodeId = nodeId
        }

    }

    fun onCanvasTapped(offset: Offset) {
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            lastTappedLocation = offset
        }
    }


    fun addEdge() {
        Log.i("onNodeClick:addEdge","${recentlyClickedNodes[0]},${recentlyClickedNodes[1]}",)
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            undoManager.execute(AddEdgeCommand(recentlyClickedNodes[0], recentlyClickedNodes[1], graph))
        }
    }

    fun onDone() {
        onInputComplete(
            GraphEditorResult(
                nodes = _nodes.value.map { it.copy(clickable = false, draggable = false) },
                edges = _edges.value,
                adjacencyList = adjacencyList
            )
        )
    }

    init {
        CoroutineScope(Dispatchers.IO).launch {
            graph.nodes.collect { list ->
                _nodes.update {
                    list.map {
                        NodeComposableState(
                            label = it.label, size = size,
                            sizePx = sizePx, id = it.id, offset = it.offset
                        )
                    }
                }
            }

        }
        CoroutineScope(Dispatchers.IO).launch {
            graph.edges.collect { list ->
                _edges.update {
                    list.map { pair ->
                        EdgeComposableState(
                            startPoint = pair.first.offset + Offset(sizePx / 2, sizePx / 2),
                            endPoint = pair.second.offset + Offset(sizePx / 2, sizePx / 2)
                        )
                    }
                }
            }
        }
    }
}