package com.khalekuzzamanjustcse.graph_editor.edtior

import android.util.Log
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.unit.dp
import com.khalekuzzamanjustcse.graph_editor.edge.GraphEditorVisualEdge
import com.khalekuzzamanjustcse.graph_editor.edge.GraphEditorVisualEdgeImp
import com.khalekuzzamanjustcse.graph_editor.edge.GraphEditorVisualEdgeMangerImp
import com.khalekuzzamanjustcse.graph_editor.node.Node
import com.khalekuzzamanjustcse.graph_editor.node.NodeManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/*
 onTap:
 Tapping support two operations:
 1:Add a node to a to tapped location.
 2:Select a control point of an edge
 to distinguish which operation is running ,we have to keep track of the operation.
 if the user clicked to add node button then change mode=AddNode
 when onTap() executed if mode==AddNode then add the node,otherwise do something else.
 after tap if mode==AddNode is on then change the mode.
 */
enum class GraphEditorMode {
    NodeAdd, DragNode, EdgeAdd, DragEdge, None
}

interface GraphManger {

}

data class GraphEditorManger(
    private val density: Float,
) {
    private val nodeManger = NodeManager(density)
    private val edgeManger = GraphEditorVisualEdgeMangerImp()
    val edges: StateFlow<List<GraphEditorVisualEdge>>
        get() = edgeManger.edges
    val nodes: StateFlow<Set<Node>>
        get() = nodeManger.nodes

    private var operationMode = GraphEditorMode.None
    private var nextAddedNode: Node? = null
    private var autoGeneratedNodeId: Int = 1
    private var autoGeneratedEdgeId: Int = 1
    val currentAddingEdge = edgeManger.currentAddingEdge
     var selectedNode=MutableStateFlow<Node?>(null)
    private set

     var selectedEdge =MutableStateFlow<GraphEditorVisualEdge?>(null)
         private set


    fun onAddNodeRequest(cost: String) {
        nextAddedNode = Node(id = autoGeneratedNodeId++, density = density, text = cost)
        operationMode = GraphEditorMode.NodeAdd
    }

    fun onRemoveNodeRequest() {
        selectedNode.value?.let {
            nodeManger.removeNode(it)
        }
    }
    fun onRemoveEdgeRequest(){
        selectedEdge.value?.let {
            edgeManger.removeEdge(it)
        }

    }

    fun onEdgeConstInput(cost: String) {
        operationMode = GraphEditorMode.EdgeAdd
        edgeManger.addEdge(
            GraphEditorVisualEdgeImp(
                id = autoGeneratedEdgeId++,
                start = Offset.Zero,
                end = Offset.Zero,
                control = Offset.Zero,
                cost = cost,
                minTouchTargetPx = 30.dp.value * density
            )
        )
    }

    fun onTap(tappedPosition: Offset) {
        selectedNode.value = nodeManger.nodeTapped(tappedPosition)
        selectedEdge.value=edgeManger.selectedEdge(tappedPosition)

        when (operationMode) {
            GraphEditorMode.NodeAdd -> {
                addNode(tappedPosition)
                operationMode = GraphEditorMode.None
            }

            else -> {
                edgeManger.onTap(tappedPosition)
            }
        }
    }


    fun onDragStart(startPosition: Offset) {
        nodeManger.onDragStart(startPosition)
        edgeManger.onDragStart(startPosition)
    }

    fun onDrag(dragAmount: Offset) {
        nodeManger.onDragging(dragAmount)
        edgeManger.dragOngoing(dragAmount, dragAmount)
    }

    fun dragEnd() {
        nodeManger.onDragEnd()
        edgeManger.dragEnded()
    }

    private fun addNode(position: Offset) {
        nextAddedNode?.let {
            val radius = it.minNodeSize.value * density / 2
            nodeManger.add(it.copy(topLeft = position - Offset(radius, radius)))
        }
    }

}